<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Arthuron AutoStart — Synchro ON/OFF</title>
<style>
  body{background:#0b0b10;color:#fff;font-family:sans-serif;margin:20px}
  #toggleBtn{padding:10px 14px;font-size:18px;border:2px solid #333;border-radius:6px;font-weight:700;cursor:pointer}
  #log{background:#111;color:#0f0;padding:10px;height:220px;overflow:auto;white-space:pre-wrap}
  .on{background:#1e8e3e;color:#fff}.off{background:#a11;color:#fff}
</style>
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
</head>
<body>
  <h1>Arthuron AutoStart</h1>
  <p>Status: <span id="status">prêt</span></p>
  <button id="toggleBtn" class="off">OFF</button>
  <audio id="remoteAudio" autoplay></audio>
  <pre id="log"></pre>

<script>
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const btn = document.getElementById('toggleBtn');
const remoteAudio = document.getElementById('remoteAudio');

remoteAudio.autoplay = true;
remoteAudio.playsInline = true;
remoteAudio.muted = false;

function log(m){ logEl.textContent += m + "\n"; logEl.scrollTop = logEl.scrollHeight; console.log(m); }
function setStatus(s){ statusEl.textContent = s; }
function uiSet(on){
  if(on){ btn.textContent='ON'; btn.classList.add('on'); btn.classList.remove('off'); }
  else  { btn.textContent='OFF'; btn.classList.add('off'); btn.classList.remove('on'); }
}

let pc=null, micStream=null, dataChannel=null;
let session=null;
let running=false;
let changing=false;
let didIntro = false;

async function fetchSession(){
  const r = await fetch('/session');
  const txt = await r.text();
  try { return JSON.parse(txt); }
  catch(e){ log('SESSION BODY:\n'+txt); throw e; }
}

function once(target, event){
  return new Promise(res=>{
    const h = (...a)=>{ target.removeEventListener(event, h); res(...a); };
    target.addEventListener(event, h);
  });
}

async function startArthuron(){
  if(running) return;
  setStatus('initialisation…');
  session = await fetchSession();
  const KEY = session?.client_secret?.value;
  const model = session?.model || 'gpt-4o-mini-realtime-preview';
  const voiceFromSession = session?.voice || session?.default_voice || 'ash';
  if(!KEY) throw new Error('EPHEMERAL_KEY manquant');

  pc = new RTCPeerConnection();
  pc.onconnectionstatechange = ()=>log('[pc] '+pc.connectionState);

  // Track promise pour savoir quand le flux audio distant est prêt
  const trackReady = new Promise(res=>{
    pc.ontrack = e=>{
      remoteAudio.srcObject = e.streams[0];
      log('[pc] ontrack');
      res();
    };
  });

  micStream = await navigator.mediaDevices.getUserMedia({
    audio: {echoCancellation:true,noiseSuppression:true,autoGainControl:true}
  });
  micStream.getTracks().forEach(t=>pc.addTrack(t, micStream));

  dataChannel = pc.createDataChannel('oai-events');

  // Collecte d’erreurs depuis la datachannel
  dataChannel.onmessage = (ev)=>{
    try{
      const msg = JSON.parse(ev.data);
      if(msg?.type === 'error'){
        log('[dc][error] ' + (msg.error || JSON.stringify(msg)));
      }
    }catch{}
  };

  // On n’envoie PAS encore l’intro ici.
  const dcOpen = new Promise(res=>{
    dataChannel.onopen = ()=>{
      log('[dc] open');
      // On pousse les instructions dans la session courante
      const instructions = session?.persona || "Tu es Arthuron.";
      dataChannel.send(JSON.stringify({
        type: "session.update",
        session: { instructions, voice: voiceFromSession }
      }));
      res();
    };
  });

  const offer = await pc.createOffer({offerToReceiveAudio:true});
  await pc.setLocalDescription(offer);

  const sdpResp = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}`, {
    method:'POST',
    headers:{ 'Authorization':`Bearer ${KEY}`, 'Content-Type':'application/sdp' },
    body: offer.sdp
  });
  if(!sdpResp.ok){
    const t = await sdpResp.text();
    throw new Error(`SDP error (${sdpResp.status}): ${t.slice(0,200)}`);
  }
  const answer = {type:'answer', sdp: await sdpResp.text()};
  await pc.setRemoteDescription(answer);

  // ✅ Attendre datachannel OUVERTE + premier track audio
  await Promise.all([dcOpen, trackReady]);

  setStatus('connecté — parle près du micro');
  running = true;
  log('✅ Realtime connecté');

  // --- INTRO FIABLE ---
  try{
    const intro = session?.greeting || "Arthuron… vieux banc. Fatigué.";
    // Clé de mémo propre à la session (évite un blocage de tests)
    const sessId = session?.id || session?.client_secret?.id || (Date.now()+Math.random()).toString(36);
    const greetedKey = `arthuron_greeted_${sessId}`;
    const greetedOnce = sessionStorage.getItem(greetedKey) === "1";

    if(!didIntro && !greetedOnce){
      didIntro = true;
      // petite latence pour laisser l’ASR se taire
      await new Promise(r=>setTimeout(r, 220));
      const payload = {
        type: "response.create",
        response: {
          modalities: ["audio"],
          instructions: intro,
          // voice explicite par sécurité
          voice: voiceFromSession,
          conversation: "none"
        }
      };
      dataChannel.send(JSON.stringify(payload));
      sessionStorage.setItem(greetedKey, "1");
      log("[dc] intro envoyée");
    }else{
      log("[dc] intro déjà jouée");
    }
  }catch(e){
    log("[dc] intro failed: " + (e?.message||e));
    // Retry light une fois si ça plante au tout début
    try{
      await new Promise(r=>setTimeout(r, 400));
      dataChannel.send(JSON.stringify({
        type: "response.create",
        response: { modalities:["audio"], instructions:(session?.greeting || "Arthuron… vieux banc. Fatigué."), voice: (session?.voice || 'ash'), conversation:"none" }
      }));
      log("[dc] intro retry ok");
    }catch(e2){
      log("[dc] intro retry failed: " + (e2?.message||e2));
    }
  }
}

function stopArthuron(){
  if(!running) return;
  try{
    if(dataChannel){ try{ dataChannel.close(); }catch{} }
    if(pc){ try{ pc.close(); }catch{} }
    if(micStream){ micStream.getTracks().forEach(t=>{ try{ t.stop(); }catch{} }); }
  }finally{
    dataChannel=null; pc=null; micStream=null; remoteAudio.srcObject=null;
    setStatus('prêt'); running=false; log('⏹️  Session arrêtée');
  }
}

/* ---------- Synchro Socket.IO ---------- */
const socket = io();
socket.on('connect_error', (e)=>log('[socket] connect_error '+(e?.message||e)));
socket.on('disconnect', (r)=>log('[socket] disconnect '+r));
socket.on('connect', ()=>log('[socket] connect'));
socket.on('state_update', async (st)=>{
  const wantOn = (st?.status === 'ON');
  log('[socket] state_update => '+st?.status);
  uiSet(wantOn);
  if(changing) return;
  try{
    changing = true;
    if(wantOn && !running) await startArthuron();
    if(!wantOn && running)  stopArthuron();
  }catch(e){
    log('Erreur synchro: '+(e?.message||e));
  }finally{
    changing = false;
  }
});

/* ---------- Clic utilisateur : OPTIMISTIC ACTION ---------- */
btn.addEventListener('click', async ()=>{
  const goingOn = (btn.textContent.trim() === 'OFF'); // cible = ON ?
  uiSet(goingOn);

  // Action locale immédiate (pas d’attente socket)
  try{
    if(!changing){
      changing = true;
      if(goingOn && !running) await startArthuron();
      if(!goingOn && running)  stopArthuron();
    }
  } catch(e){
    log('Erreur action locale: '+(e?.message||e));
  } finally {
    changing = false;
  }

  // Informe le serveur (synchro autres clients)
  try{
    const r = await fetch('/state', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ status: goingOn ? 'ON' : 'OFF' })
    });
    if(!r.ok){ const t = await r.text(); throw new Error(`POST /state ${r.status}: ${t}`); }
  }catch(e){
    log('Erreur /state: '+(e?.message||e));
  }
});




  const offer = await pc.createOffer({offerToReceiveAudio:true});
  await pc.setLocalDescription(offer);

  // Appel direct OpenAI (comme ta version qui marche)
  const sdpResp = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}`, {
    method:'POST',
    headers:{ 'Authorization':`Bearer ${KEY}`, 'Content-Type':'application/sdp' },
    body: offer.sdp
  });
  if(!sdpResp.ok){
    const t = await sdpResp.text();
    throw new Error(`SDP error (${sdpResp.status}): ${t.slice(0,200)}`);
  }
  const answer = {type:'answer', sdp: await sdpResp.text()};
  await pc.setRemoteDescription(answer);

  setStatus('connecté — parle près du micro');
  running = true;
  log('✅ Realtime connecté');
}

function stopArthuron(){
  if(!running) return;
  try{
    if(dataChannel){ try{ dataChannel.close(); }catch{} }
    if(pc){ try{ pc.close(); }catch{} }
    if(micStream){ micStream.getTracks().forEach(t=>{ try{ t.stop(); }catch{} }); }
  }finally{
    dataChannel=null; pc=null; micStream=null; remoteAudio.srcObject=null;
    setStatus('prêt'); running=false; log('⏹️  Session arrêtée');
  }
}

/* ---------- Synchro globale via Socket.IO ---------- */
const socket = io(); // même domaine
socket.on('connect', ()=>log('[socket] connect'));
socket.on('state_update', async (st)=>{
  const wantOn = (st?.status === 'ON');
  log('[socket] state_update => '+st?.status);
  uiSet(wantOn);
  if(changing) return;
  try{
    changing = true;
    if(wantOn && !running) await startArthuron();
    if(!wantOn && running)  stopArthuron();
  }catch(e){
    log('Erreur synchro: '+(e?.message||e));
  }finally{
    changing = false;
  }
});

/* ---------- Clic utilisateur ---------- */
btn.addEventListener('click', async ()=>{
  const target = (btn.textContent.trim() === 'OFF') ? 'ON' : 'OFF';
  uiSet(target === 'ON');
  try{
    const r = await fetch('/state', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ status: target })
    });
    if(!r.ok){ const t = await r.text(); throw new Error(`POST /state ${r.status}: ${t}`); }
    // Le start/stop réel se fait à la réception de state_update (synchro multi-clients)
  }catch(e){
    log('Erreur /state: '+(e?.message||e));
  }
});
</script>
</body>
</html>
