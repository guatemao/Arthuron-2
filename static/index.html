<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Arthuron AutoStart avec Persona</title>
</head>
<body style="background:#0b0b10; color:white; font-family:sans-serif;">
  <h1>Arthuron AutoStart</h1>
  <p>Status: <span id="status">prêt</span></p>
  <audio id="remoteAudio" autoplay></audio>
  <audio id="introAudio" src="/static/intro.wav" preload="auto" playsinline></audio>
<button id="startBtn" style="display:none; margin-top:10px;">Lancer</button>
<pre id="log" style="background:#111; color:#0f0; padding:10px; height:200px; overflow:auto;"></pre>
<script>
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
function log(msg){ logEl.textContent += msg + "\n"; logEl.scrollTop = logEl.scrollHeight; console.log(msg); }
function setStatus(s){ statusEl.textContent = s; }

let pc, micStream, dataChannel, session = null;
let introPlaying = false;

async function fetchSession() {
  const r = await fetch('/session');
  const txt = await r.text();
  try { return JSON.parse(txt); }
  catch(e){ console.error('SESSION BODY:', txt); throw e; }
}

async function startSession() {
  setStatus('initialisation…');
  session = await fetchSession();
  const EPHEMERAL_KEY = session?.client_secret?.value;
  const model = session?.model || 'gpt-4o-mini-realtime-preview';
  if (!EPHEMERAL_KEY) { setStatus('pas de token'); return; }

  pc = new RTCPeerConnection();
  pc.onconnectionstatechange = () => log('[pc] ' + pc.connectionState);
  pc.onicecandidate = () => {};

  const remoteEl = document.getElementById('remoteAudio');

  pc.ontrack = (e) => {
    // On attache le flux mais on le mute si l’intro joue encore
    remoteEl.srcObject = e.streams[0];
    remoteEl.muted = introPlaying;
  };

  // Micro
  if (!micStream) {
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
    });
  }
  micStream.getTracks().forEach(t => pc.addTrack(t, micStream));

  // DataChannel + persona
  dataChannel = pc.createDataChannel("oai-events");
  dataChannel.onopen = () => {
    log('[dc] open');
    const instructions = session?.persona || "Tu es Arthuron par défaut.";
    dataChannel.send(JSON.stringify({ type:"session.update", session:{ instructions } }));
  };
  dataChannel.onmessage = (e)=>log('[dc msg] ' + e.data);

  // SDP
  const offer = await pc.createOffer({ offerToReceiveAudio:true });
  await pc.setLocalDescription(offer);
  const sdpResponse = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}`, {
    method:"POST",
    body: offer.sdp,
    headers:{ "Authorization":`Bearer ${EPHEMERAL_KEY}`, "Content-Type":"application/sdp" }
  });
  if (!sdpResponse.ok) {
    const t = await sdpResponse.text();
    console.error('SDP error:', t);
    setStatus('erreur SDP');
    return;
  }
  const answer = { type:"answer", sdp: await sdpResponse.text() };
  await pc.setRemoteDescription(answer);
  setStatus('connecté — parle près du micro');
}

// ---- Intro en parallèle + “gating” du son Realtime ----
async function playIntroParallel() {
  const intro = document.getElementById('introAudio');
  const remoteEl = document.getElementById('remoteAudio');
  if (!intro) { log('[intro] introuvable'); return; }

  introPlaying = true;
  remoteEl.muted = true;              // on coupe le flux Realtime le temps de l’intro
  setStatus('intro…');

  // Tentatives simples (pas de bouton) :
  try {
    intro.currentTime = 0;
    intro.playsInline = true;
    intro.muted = false;
    await intro.play();               // peut être refusé par autoplay policy
  } catch (e1) {
    log('[intro] autoplay bloqué, on tente après getUserMedia');
    // Après getUserMedia ça passe parfois mieux
    try {
      if (!micStream) {
        micStream = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
        });
      }
      intro.currentTime = 0;
      intro.muted = false;
      await intro.play();
    } catch (e2) {
      log('[intro] encore bloqué: ' + e2);
      // Rien ne marche: on arrête proprement et on libère l’audio Realtime
      introPlaying = false;
      remoteEl.muted = false;
      setStatus('intro bloquée (autoplay). Session en cours.');
      return;
    }
  }

  intro.addEventListener('ended', () => {
    // Fin de l’intro -> on ouvre le son Realtime
    introPlaying = false;
    // Option: petit fondu si le navigateur supporte volume
    try {
      let v = 0.0;
      remoteEl.muted = false;
      remoteEl.volume = 0.0;
      const step = () => {
        v += 0.1;
        if (v >= 1) { remoteEl.volume = 1.0; return; }
        remoteEl.volume = v;
        requestAnimationFrame(step);
      };
      requestAnimationFrame(step);
    } catch {
      remoteEl.muted = false;
    }
    setStatus('connecté — parle près du micro');
  }, { once:true });
}

// ---- Boot simultané ----
window.addEventListener('load', async () => {
  // démarrage simultané
  playIntroParallel();     // ne bloque pas
  startSession().catch(e => log('[session] échec: ' + e));
});
</script>
</body>
</html>

